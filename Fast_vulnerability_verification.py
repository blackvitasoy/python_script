# -*- coding:utf-8 -*-

#https://mp.weixin.qq.com/s/Dwec68-ROfiqWeRUY4wEpg
#http://125.75.6.2:88

import argparse
import datetime
import random
from concurrent.futures import ThreadPoolExecutor
from colorama import init,Fore
from selenium import webdriver
from PIL import Image
import ddddocr
import base64
import requests
import json
import re
import time
from functools import wraps

#命令格式化
def arg():
    arg = argparse.ArgumentParser(description="POC_Verify")
    arg.add_argument("-u","--url",dest="url",help='Target URL',type=str)
    arg.add_argument("-f","--file",dest="file",help="Scan multiple targets given in a text file",type=str)
    arg.add_argument("-F","--fofa",dest="fofa",action="store_true",help="fofa query Nums/String Example")
    arg.add_argument("-p","--poc",dest="poc",help="Load POC file from database")
    arg.add_argument("-t","--thread_number",dest="threadNum",help="the thread_count,default=10",type=int,default=10)
    arg.add_argument("-o","--outfile",dest="outfile",help="the file save result",default="result.txt",type=str)
    arg.add_argument("-b","--burpsuit",dest="burpsuit",action="store_true",help="Use the Burpsuit proxy server")
    arg_result = arg.parse_args()
    return arg_result


#配置文件poc.json文件读取
def get_poc_content():
    with open("poc.json", "r", encoding="utf-8") as file:
        poc_result = json.loads(file.read())
    return poc_result

#获取目标


class GetTarget(object):
    def __init__(self,poc_result,arg_result):
        self.url = poc_result["fofa_login_url"]
        self.username = poc_result["fofa_username"]
        self.password = poc_result["fofa_password"]
        self.fofa_search = poc_result["fofa"]
        self.cookie_dict = {}
        self.errormsg = poc_result["fofa_errormsg"]
        self.urls_list = []
        self.arg_result = arg_result
        options = webdriver.ChromeOptions()
        options.add_experimental_option("excludeSwitches", ['enable-logging'])
        if arg_result.fofa:
            self.driver = webdriver.Chrome(options=options)

    def chrome(self):

        flag = True
        while flag:
            self.driver.get(self.url)
            self.driver.maximize_window()
            self.driver.find_element_by_xpath("/html/body/div[2]/div/div[2]/div[2]/form/table/tbody/tr[1]/td/input").send_keys(self.username)
            self.driver.find_element_by_xpath("/html/body/div[2]/div/div[2]/div[2]/form/table/tbody/tr[2]/td/input").send_keys(self.password)
            self.driver.find_element_by_xpath('//*[@id="login-form"]/table/tbody/tr[3]/td/input').send_keys(self._captcha())
            self.driver.find_element_by_id("rememberMe").click()
            self.driver.find_element_by_name("fofa_service").click()
            self.driver.find_element_by_xpath("/html/body/div[2]/div/div[2]/div[2]/form/table/tbody/tr[5]/td/button").click()
            cookies = self.driver.get_cookies()
            for cookie in cookies:
                self.cookie_dict[cookie['name']] = cookie['value']
            text_data = self.driver.find_element_by_xpath("/*")
            if self.errormsg in text_data.text:
                pass
            else:
                return False


    def _captcha(self):
        ocr = ddddocr.DdddOcr()
        screenImg = "c.png"
        windows_k = 1.25 #windows缩放,所以截图需乘以
        self.driver.get_screenshot_as_file(screenImg)

        imgelement = self.driver.find_element_by_id("captcha_image")
        location = imgelement.location
        size = imgelement.size
        left = int(location['x']) * windows_k
        top = int(location['y']) * windows_k
        right = int(size['width']) * windows_k + left
        height = int(size['height']) * windows_k + top
        rangle = (left,top,right,height)
        image = Image.open(screenImg)
        code_result = image.crop(rangle)
        code_result.save(screenImg)

        with open(screenImg,"rb") as file:
            img_bites = file.read()
            code_result = ocr.classification(img_bites)

        return code_result

    def fofa_get_data(self):
        pattern = re.compile(r'<span class="aSpan"><a href=".*?" target="_blank">(.*?)<i class="iconfont icon-link">')
        sentence = base64.b64encode(self.fofa_search.encode("utf-8")).decode("utf-8")
        for i in range(10):
            fofa_search_url = f"https://fofa.info/result?qbase64={sentence}&page={i}&page_size=20"
            headers = {"User-Agent":"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0"}
            response = requests.get(fofa_search_url,cookies=self.cookie_dict,headers=headers)
            re_result = pattern.findall(response.text)
            for data in re_result:
                self.urls_list.append(data)
        self.driver.quit() #保证添加完数据再关闭浏览器

    def getTargetFormyself(self):
        urls_path = self.arg_result.file
        if self.arg_result.url != None and self.arg_result.file == None:
            self.urls_list.append(self.arg_result.url)
        elif self.arg_result.file != None and self.arg_result.url == None:
            try:
                with open(urls_path, "r", encoding="utf-8") as target_file:
                    for line in target_file.readlines():
                        self.urls_list.append(line.strip("\n"))
            except Exception as e:
                print("报错了", e)
        else:
            print("请输入有效目标")

    def url_parser(self):
        processed_url_list = []
        for url in self.urls_list:
            if "https://" not in url:
                if "http://" in url:
                    url = url
                else:
                    url = "http://" + url
            processed_url_list.append(url)
        return processed_url_list

    def get_url_list(self):
        if self.arg_result.fofa:
            self.chrome()
            self.fofa_get_data()
            url_list = self.url_parser()
        else:
            self.getTargetFormyself()
            url_list = self.url_parser()
        return url_list

#生成请求头
def requestHeaders(poc_result):
    headers = {}
    if not poc_result["request"]["headers"]["User-Agent"]:
        useragent = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0"
        headers = {"User-Agent": useragent}
    else:
        headers["User-Agent"] = poc_result["request"]["headers"]["User-Agent"]

    if not poc_result["request"]["headers"]["X-Forwarded-For"]:
        ip = ""
        for i in range(4):
            tmp = random.randrange(255)
            ip = ip + str(tmp) + "."
        ip = ip[:-1]
        headers['X-Forwarded-For'] = ip
    else:
        headers["X-Forwarded-For"] = poc_result["request"]["headers"]["X-Forwarded-For"]

    if not poc_result["request"]["headers"]["referer"]:
        headers['referer'] = "www.baidu.com"
    else:
        headers["referer"] = poc_result["request"]["headers"]["referer"]

    return headers

#发送请求
def sendRequest(arg_result,headers,poc_result,url):
    init(autoreset=True)
    method = poc_result["request"]["method"]
    data = poc_result["request"]["data"]
    confirm = poc_result["confirm"]
    poc_url = poc_result["request"]["url"]
    complection_url = str(url) + poc_url
    if arg_result.burpsuit:
        proxies = {"http":"127.0.0.1:8080","https":"127.0.0.1:8080"}
    else:
        proxies = {}
    try:
        response = requests.request(method=method, url=complection_url, headers=headers,data=data,proxies=proxies,verify=False,timeout=3)
        response.encoding = "utf-8"
        if response.status_code == 200 and confirm in response.text:
            print(Fore.RED + f"[+]存在漏洞 {url}")
            return url

        else:
            print(f"[-]不存在漏洞,{url}")
    except Exception as e:
        print(f"[-]请求不可达 {url}")

#输出结果
def output_result(result_list,arg_result):
    if not arg_result.outfile:
        filepath = arg_result.outfile
    else:
        filepath = datetime.datetime.now().strftime("%Y%m%d") + ".txt"
    with open(filepath,"w") as file:
        if result_list != None:
            for result in result_list:
                file.write(result+"\n")
            print("存在漏洞结果有" + str(len(result_list)) + f"条，已保存在{filepath}里!")
        else:
            print("没有发现存在漏洞的目标")


def concurrentRequests(url_list,arg_result,headers,poc_result):
    with ThreadPoolExecutor(max_workers=10) as pool:
        result_list = []
        for url in url_list:
            Futere_result = pool.submit(sendRequest,arg_result,headers,poc_result,url)
            result = Futere_result.result()
            if result != None:
                result_list.append(result)
    return result_list

def fn_timer(function):
    @wraps(function)
    def function_timer(*args,**kwargs):
        t0 = time.time()
        result = function(*args,**kwargs)
        t1 = time.time()
        print("总共使用了 %s 秒" %(str(t1-t0)))
        return result
    return function_timer

@fn_timer
def main():
    # 获取命令行参数
    arg_result = arg()
    # 获取poc参数
    poc_result = get_poc_content()
    #获取url_list
    get_target_object = GetTarget(poc_result,arg_result)
    url_list = get_target_object.get_url_list()
    # 获取请求头
    headers = requestHeaders(poc_result)
    #并发请求url
    result_list = concurrentRequests(url_list,arg_result,headers,poc_result)
    #获取结果
    output_result(result_list,arg_result)


if __name__ == "__main__":
    main()